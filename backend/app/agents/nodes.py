from app.config import llm
from app.agents.sql import agent_sql
from app.agents.chatstate import ChatState
from app.agents.tools import fetch_and_analyze_web_html_node
from langchain.prompts import PromptTemplate

def is_natural_query(text: str) -> bool:
    email_indicators = ["subject:", "dear", "regards", "best", "sincerely", "message", "thank you"]
    if any(word in text.lower() for word in email_indicators) or len(text.split("\n")) > 5:
        return False  # It's likely an email
    return True  # It's likely a direct query

# === Email-to-Query Prompt Template ===
email_parse_prompt = PromptTemplate.from_template("""
From the email below, extract a clear and concise query intention in English that describes what information the user wants from the database.
===
{email}
===
Only respond with the query intention.
""")

parse_chain = email_parse_prompt | llm


# === Node Definitions ===
def parse_email(state: ChatState) -> ChatState:
    # print("[DEBUG] parse_email - input state:", state)
    email = state.get("email_content", "").strip()
    if is_natural_query(email):
        user_query = email
    else:
        response = parse_chain.invoke({"email": email})
        user_query = response.content.strip()
    new_state: ChatState = {
        "email_content": email,
        "user_query": user_query,
        "summary": state.get("summary", ""),
        "next_node": "select_tool"
    }
    # print("[DEBUG] parse_email - output state:", new_state)
    return new_state

def select_tool(state: ChatState) -> ChatState:
    prompt = (
        f"Given the question: '{state['user_query']}', decide which tool to use:\n"
        "1. If the question is about retrieving data from the database, return 'sql_query'.\n"
        "2. If the question requires analyzing web content, return 'web_analysis'.\n"
        "ONLY return the exact tool name without explanation."
    )
    predicted_label = llm.invoke(prompt).content.strip().lower()

    new_state = state.copy()
    if predicted_label == "sql_query":
        new_state["next_node"] = "sql_agent"
    elif predicted_label == "web_analysis":
        new_state["next_node"] = "web_analysis"
    else:
        new_state["next_node"] = "generate_email_reply"
    
    return new_state

def sql_agent_node(state: ChatState) -> ChatState:
    try:
        result = agent_sql.invoke({"input": state["user_query"]})
        if isinstance(result, dict):
            summary = result.get("output", "")
            if not summary:
                summary = str(result)
        else:
            summary = str(result)
    except Exception as e:
        summary = f"Error occurred during SQL query: {e}"
    
    new_state = state.copy()
    new_state["summary"] = summary
    new_state["next_node"] = "generate_email_reply"
    return new_state

def web_analysis_node(state: ChatState) -> ChatState:
    try:
        result = fetch_and_analyze_web_html_node.invoke({"query": state["user_query"]})
        if isinstance(result, dict):
            summary = result.get("summary", str(result))
        else:
            summary = str(result)
    except Exception as e:
        summary = f"Error occurred during web analysis: {e}"
    
    new_state = state.copy()
    new_state["summary"] = summary
    new_state["next_node"] = "generate_email_reply"
    return new_state

def generate_email_reply(state: ChatState) -> ChatState:
    reply = f"""
    Dear Client,

    Thank you for your inquiry. Below is the summarized information based on your request:
    {state.get('summary', '')}

    If you have any further questions, feel free to reach out.

    This email was automatically generated by BDM.chat assistant.
    """
    print("\n=== Generated Email Response ===\n")
    print(reply)
    return state