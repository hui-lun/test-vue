import logging

from app.config import llm
from app.agents.sql import agent_sql
from app.agents.chatstate import ChatState
from app.agents.tools import fetch_and_analyze_web_html, run_sql_agent, analyze_spec_tool
from langchain.prompts import PromptTemplate
from langchain.agents import create_react_agent, AgentExecutor

logger = logging.getLogger(__name__)

def is_natural_query(text: str) -> bool:
    email_indicators = ["subject:", "dear", "regards", "best", "sincerely", "message", "thank you"]
    if any(word in text.lower() for word in email_indicators) or len(text.split("\n")) > 5:
        return False  # It's likely an email
    return True  # It's likely a direct query

# === Email-to-Query Prompt Template ===
email_parse_prompt = PromptTemplate.from_template("""
From the email below, extract a clear and concise query intention in English that describes what information the user wants from the database.
===
{email}
===
Only respond with the query intention.
""")

parse_chain = email_parse_prompt | llm

# === Node Definitions ===
def parse_email(state: ChatState) -> ChatState:
    # logger.info("[Tool Branch] Executing parse_email (Email parsing)")
    email = state.get("email_content", "").strip()
    if is_natural_query(email):
        user_query = email
    else:
        response = parse_chain.invoke({"email": email})
        user_query = response.content.strip()
    new_state: ChatState = {
        "email_content": email,
        "user_query": user_query,
        "summary": state.get("summary", ""),
        "next_node": "react_agent"
    }
    # logger.debug("[DEBUG] parse_email - output state: %s", new_state)
    return new_state


# tools=[run_sql_agent, fetch_and_analyze_web_html, analyze_spec_tool]
tools=[fetch_and_analyze_web_html, analyze_spec_tool]


react_prompt = PromptTemplate.from_template(
    "You are a helpful assistant that uses tools to answer questions.\n"
    "You have access to the following tools:\n"
    "{tools}\n"
    "\n"
    "Use the following format:\n"
    "Question: the input question you must answer\n"
    "Thought: you should always think about what to do\n"
    "Action: the action to take, should be one of [{tool_names}]\n"
    "Action Input: the input to the action\n"
    "Observation: the result of the action\n"
    "... (this Thought/Action/Action Input/Observation can be repeated zero or more times)\n"
    "Thought: I now know the final answer\n"
    "Final Answer: the final answer to the original input question\n"
    "\n"
    "Question: {input}\n"
    "Thought: I need to decide which tool to use to answer this question\n"
    "Action: the action to take, should be one of [{tool_names}]\n"
    "Action Input: {input}\n"
    "Observation: the result of the action\n"
    "Thought: I now know which tool to use\n"
    "Final Answer: {agent_scratchpad}\n"
)

react_agent = create_react_agent(
    llm=llm,
    tools=tools,
    prompt=react_prompt
)

def select_tool_agent(state: ChatState) -> ChatState:
    try:
        agent_executor = AgentExecutor(agent=react_agent, tools=tools, verbose=True)
        result = agent_executor.invoke({"input": state["user_query"]})
        
        summary = ""
        if isinstance(result, dict) and isinstance(result.get("output"), dict):
            summary = result["output"].get("summary", "")
        elif isinstance(result, dict) and "summary" in result:
            summary = result["summary"]
        else:
            summary = str(result)

        new_state: ChatState = {
            "email_content": state.get("email_content", ""),
            "user_query": state.get("user_query", ""),
            "summary": summary,
            "next_node": "generate_email_reply"
        }
        return new_state
    except Exception as e:
        logger.error("[React Agent] Error in react_agent_node:", exc_info=True)
        return {
            "email_content": state.get("email_content", ""),
            "user_query": state.get("user_query", ""),
            "summary": f"Error occurred during React Agent execution: {str(e)}",
            "next_node": "generate_email_reply"
        }

def generate_email_reply(state: ChatState) -> ChatState:
    reply = f"""
    Dear Client,

    Thank you for your inquiry. Below is the summarized information based on your request:
    {state.get('summary', '')}

    If you have any further questions, feel free to reach out.

    This email was automatically generated by BDM.chat assistant.
    """
    print("\n=== Generated Email Response ===\n")
    print(reply)
    return state